#!/usr/bin/env bash

set -e

usage() {
	echo "usage: cache [--ttl SECONDS] [--cache-status CACHEABLE-STATUSES] [cache-key] [command] [args for command]"
	echo "	--ttl SECONDS	# Treat previously cached content as fresh if fewer than SECONDS seconds have passed"
	echo "	--cache-status	# Quoted and space-delimited exit statuses for [command] that are acceptable to cache."
	echo "	--help		# show this help documentation"
}

while [[ $# -gt 0 ]]
do
	key="$1"

	case $key in
		--cache-status)
			acceptable_statuses="$2"
			shift # drop the key
			shift # drop the value
			;;
		--help)
			usage
			exit 0
			;;
		--ttl)
			ttl="$2"
			shift # drop the key
			shift # drop the value
			;;
		--)
			cache_key=$2
			shift # drop the --
			shift # drop the cache key
			break
			;;
		*) # default
			if [ -z "$cache_key" ]; then
				cache_key=$1
				shift
			else
				break;
			fi
			;;
	esac
done

cache_dir=${CACHE_DIR:-$TMPDIR}
cache_file="$cache_dir$cache_key"

fresh () {
	# if the $cache_file doesn't exist, it can't be fresh
	if [ ! -f "$cache_file" ]; then
		return 1
	fi

	# if we don't have a ttl specifed, our $cache_file is
	# fresh-enough
	if [ -z "$ttl" ]; then
		return 0
	fi

	# if a ttl is specified, we need to check the last modified
	# timestamp on the $cache_file
	if [[ "$OSTYPE" == "darwin"* ]]; then
		mtime=$(stat -f %m "$cache_file")
	else
		mtime=$(stat -c %Y "$cache_file")
	fi

	now=$(date +%s)
	remaining_time=$((now - mtime))

	if [ $remaining_time -lt "$ttl" ]; then
		return 0
	fi

	return 1
}

if fresh; then
	status=$(cat "$cache_file.cache-status")
	cat "$cache_file"
else
	"$@" | tee "$cache_file"
	status=${PIPESTATUS[0]}

	acceptable_statuses=${acceptable_statuses:-0}
	# shellcheck disable=SC2076
	if [[ $acceptable_statuses != "*" ]] && [[ ! " $acceptable_statuses " = *" $status "* ]]; then
		rm "$cache_file"
	else
		echo "$status" > "$cache_file.cache-status"
	fi
fi

exit "$status"
