#!/usr/bin/env bash

set -e

usage() {
	echo "usage: cache [--ttl SECONDS] [--cache-status CACHEABLE-STATUSES] [cache-key] [command] [args for command]"
	echo "	--ttl SECONDS	# Treat previously cached content as fresh if fewer than SECONDS seconds have passed"
	echo "	--cache-status	# Quoted and space-delimited exit statuses for [command] that are acceptable to cache."
	echo "	--help		# show this help documentation"
}

positional=()
while [[ $# -gt 0 ]]
do
	key="$1"

	case $key in
		--cache-status)
			acceptable_statuses="$2"
			shift # drop the key
			shift # drop the value
			;;
		--help)
			usage
			exit 0
			;;
		--ttl)
			ttl="$2"
			shift # drop the key
			shift # drop the value
			;;
		--)
			shift
			positional+=("$@")
			break
			;;
		*)    # default
			positional+=("$1") # save it in an array for later
			shift # drop the argument
			;;
	esac
done

set -- "${positional[@]}" # restore positional parameters
cache_key=$1
shift

cache_dir=${CACHE_DIR:-$TMPDIR}
cache_file="$cache_dir$cache_key"

fresh () {
	# if the $cache_file doesn't exist, it can't be fresh
	if [ ! -f $cache_file ]; then
		return 1
	fi

	# if we don't have a ttl specifed, our $cache_file is
	# fresh-enough
	if [ -z "$ttl" ]; then
		return 0
	fi

	# if a ttl is specified, we need to check the last modified
	# timestamp on the $cache_file
	mtime=$(stat -f %m $cache_file)
	now=$(date +%s)
	remaining_time=$(($now - $mtime))

	if [ $remaining_time -lt $ttl ]; then
		return 0
	fi

	return 1
}

if fresh; then
	status=$(cat "$cache_file.cache-status")
	cat $cache_file
else
	"$@" | tee $cache_file
	status=${PIPESTATUS[0]}

	acceptable_statuses=${acceptable_statuses:-0}
	if [[ $acceptable_statuses != "*" ]] && [[ ! " $acceptable_statuses " =~ " $status " ]]; then
		rm $cache_file
	else
		echo $status > "$cache_file.cache-status"
	fi
fi

exit $status
